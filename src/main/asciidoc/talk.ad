= Spring Data JDBC
:icons: font
:twitter-tag: @jensschauder
:conference-tag: @jug_de
:talk-tag: #sd-jdbc
:slide-link: http://bit.ly/talk-sd-jdbc
:linkattrs:
:main-incl: {src-incl}/src/main/java/de/schauderhaft/spring/data/jdbc/talk/
:test-incl: {src-incl}/src/test/java/de/schauderhaft/spring/data/jdbc/talk/
:res-incl: {src-incl}/src/main/resources/

include::footer.ad[]

{nbsp} +
{nbsp} +

[small]#Press S for speaker notes#

== Talk Motto

image::shame.png[canvas,size=contain]

[quote, "Reid Hoffman"]
____
If you are not embarrassed by the first version of your product, youâ€™ve launched too late.
____

=== Default Answer

* No that feature doesn't exist yet.

* We accept pull requests.

[NOTE.speaker]
====
I'll do my work, but it will take time.
====

== Spring Data

image::spring-data.png[canvas,size=contain]

[NOTE.speaker]
====
* Consistent Programming Model for data access.

* Inspired by DDD

* Modules for JPA, Mongo, Cassandra, Neo4j ...

* Repository Abstraction
====

== JPA vs Spring Data Jdbc

image::jpa-sdjdbc.png[canvas,size=contain]

=== JPAs complexity

[NOTE.speaker]
====
JPAs enormous power comes with considerable complexity
====

=== Lazy Loading (Exception)

=== Dirty Checking

[NOTE.speaker]
====
What if you change an entity but don't want to save it?
====

=== Session / 1st Level Cache

[NOTE.speaker]
====
You can't for example load the unchanged entity in an event
====

=== Proxies for Entities

=== Map almost anything to anything

== Spring Data JDBCs Design Choices

=== No Lazy Loading

=== No Caching

=== No Proxies

=== No deferred flushing

=== Very simple & limited & opinionated ORM

=== Simplicity is King

Complexity is tempting

== Consider Spring Data JDBC

if you ...

=== want to custom code most SQL anyway

=== find yourself fighting JPA

=== want to have DDD Aggregates

(but still want to use a RDBMS)

== CrudRepository

=== Dependencies

[source, xml, indent=0, tabsize=2]
----
include::{src-incl}pom.xml[tags=sdjdbc]
----

=== The usual suspects

* hsqldb
* lombok
* junit
* spring-test
* assertj

[NOTE.speaker]
====
These are just my choices,
of course you can pick what ever you want.
====

=== Configuration

=== !

[source, java, indent=0, tabsize=2]
----
include::{main-incl}SpringleticsConfiguration.java[tags=main]
----

[NOTE.speaker]
====
You just need a `NamedParameterjdbcTemplate` but we'll need the separate `DataSource` later on.

`@EnableJdbcRepositories` finds and create repository interfaces
====

=== Entity

[source, java, indent=0, tabsize=2]
----
include::{main-incl}Workout.java[tags=main]
----

=== Entity

All you need is an `@Id`

* getters/setters are optional

* default constructor is optional

=== Repository

[source, java, indent=0, tabsize=2]
----
include::{main-incl}WorkoutRepository.java[tags=main]
----

[NOTE.speaker]
====
You just declare a with type parameters interface, the repository gets generated by Spring Data Jdbc on the fly.
====

=== Schema

[source, sql, indent=0, tabsize=2]
----
include::{res-incl}create-schema.sql[]
----

[NOTE.speaker]
====
Currently there is no DDL creation feature.
While probably necessary in the long run we might make it separate from the main module in order to avoid people using it in production.
====


=== Create, Read

[source, java, indent=0, tabsize=2]
----
include::{test-incl}SpringleticsTest.java[tags=create]
----

=== Update, Delete

[source, java, indent=0, tabsize=2]
----
include::{test-incl}SpringleticsTest.java[tags=update]
----

=== Log Output

[source,sql]
----
INSERT INTO Workout (name, focus) VALUES (?, ?)
SELECT Workout.id AS id, Workout.name AS name, Workout.focus AS focus
       FROM Workout WHERE Workout.id = ?
UPDATE Workout set id = ?, name = ?, focus = ? where id = ?
DELETE FROM Workout where id = ?
----

[NOTE.speaker]
====
All statements get executed during the matching method call.
No caching or anything.
====

=== Methods in CrudRepository

[source, java]
----
<S extends T> S save(S entity);
<S extends T> Iterable<S> saveAll(Iterable<S> entities);
Optional<T> findById(ID id);
boolean existsById(ID id);
Iterable<T> findAll();
Iterable<T> findAllById(Iterable<ID> ids);
long count();
void deleteById(ID id);
void delete(T entity);
void deleteAll(Iterable<? extends T> entities);
void deleteAll();
----

== NamingStrategy

image::name.png[canvas,size=contain]

=== PrefixNamingStrategy

[source, java, indent=0, tabsize=2]
----
include::{main-incl}namingstrategy/PrefixNamingStrategy.java[tags=naming]
----

=== Dynamic NamingStrategy

[source, java, indent=0, tabsize=2]
----
private final ThreadLocal<String> schema = new ThreadLocal<>();

new NamingStrategy() {

	@Override
	public String getSchema() {
		return schema.get();
	}
};
----

== Non trivial Aggregates

image::aggregate.png[canvas,size=contain]

=== Design Challenge

CRUD Operations for entities with references

aka ORM

[NOTE.speaker]
====
You probably want to save an `Order` with it's `items` in one go.

But

* We don't want to rebuild Hibernate.

* We want to keep things simple.

* Yet have something useful.

I killed about a month just for this one.

I hated it at first.

But by now I think it's actually quite nice.
====

=== Springletics Workout

[source,java]
----
class Workout {
    // ...
    List<Exercise> exercises
    // ...
}
----

[NOTE.speaker]
====
Let's look at an example.

A workout consists of multiple Exercises.
Think pushups or squats.
====

=== Pseudo Code

[source,pseudo]
----
wo = createWorkout();
wo = repository.save(wo);
wo = changeWorkout(wo);
repository.save(wo);
----

[NOTE.speaker]
====
create, save

change, save again

Question: How should the statements look like?
====

=== SQL Statments

[source,sql]
----
// first save
INSERT INTO Workout (name, focus) VALUES (?, ?)
INSERT INTO Exercise (name, description, Workout, Workout_key) VALUES (?, ?, ?, ?)

// second save
DELETE FROM Exercise WHERE Workout = ?
UPDATE Workout set id = ?, name = ?, focus = ? WHERE id = ?
INSERT INTO Exercise (name, description, Workout, Workout_key) VALUES (?, ?, ?, ?)
----

=== WAT?

* **DELETE ALL referenced Entities!**

* UPDATE Aggregate Root

* REINSERT ALL referenced Entities

=== What will improve

* DELETE ALL formerly referenced Entities

* UPDATE Aggregate Root

* UPDATE still referenced Entities

* INSERT new Entities

== => No Many-to-X relations!

image::seagull.png[canvas,size=contain]

[NOTE.speaker]
====
You can't have Many to anything relationships.

One to one and one to many are fine though.

Don't run away, there are reasons for this.
====

=== Repositories work on Aggregates

[quote, "Martin Fowler", https://martinfowler.com/bliki/DDD_Aggregate.html]
____
Aggregates are the basic element of transfer of data storage - you request to load or save whole aggregates.
____

[NOTE.speaker]
====
When ever you load or save something, you are dealing with complete aggregates.
====

=== Aggregate

[quote, "Martin Fowler", https://martinfowler.com/bliki/DDD_Aggregate.html]
____

Aggregate is a pattern in Domain-Driven Design.
A DDD aggregate is a cluster of domain objects that can be treated as a single unit.
____

[NOTE.speaker]
====
An entity is either part of one or the other aggregate, but it can never be part of the two aggregates.
====

=== Aggregate Root

[quote, "Martin Fowler", https://martinfowler.com/bliki/DDD_Aggregate.html]
____

An aggregate will have one of its component objects be the aggregate root.
Any references from outside the aggregate should only go to the aggregate root.
The root can thus ensure the integrity of the aggregate as a whole.
____

[NOTE.speaker]
====
If from inside of one aggregate you don't touch the stuff of another aggregate.
====

=== Many to X relations

If multiple Aggregate roots reference X,

X must be another Aggregate Root.

=> Not part of this Aggregate.

=== What is part of the Aggregate?

Everything referenced.

=== What to do

* Just reference an id.

[NOTE.speaker]
====
In the database you might consider

* no constraints across aggregates.

* deferred constraints.
====

=== But I don't like that!

* That's ok.

Use

* `@Query`

* Custom method implementations

* Custom base repository

=== Just consider for a moment

* It is a strong constraint

* It might improve your architecture

[NOTE.speaker]
====
* Makes bounds of aggregates really obvious.

* Greatly simplifies things like test setup for integration tests.

* Allows complete change of persistence strategy for one aggregate, while keeping others as they are.
====

== Events

image::event.png[canvas,size=contain]

=== Register a Listener

[source, java, indent=0, tabsize=2]
----
include::{main-incl}BeforeSaveListener.java[tags=main]
----

=== Available Events

* `BeforeSave`
* `AfterSave`
* `BeforeDelete`
* `AfterDelete`
* `AfterLoad` - when an Aggregate got instantiated from the database

=== `AggregateChange`

* A model of the changes to be applied to the database
* contains a **mutable** list of `DbAction` s.

=== `DbAction`

Represents a single SQL statement to be executed against the database.

=== Do whatever you want

* Access the repository
* change the entities
* **Change** the `AggregateChange`!

== MyBatis

image::mybatis.png[canvas,size=contain]

=== How?

=== CRUD methods get translated into DbActions

=== Each action gets mapped to a MyBatis query id.

=== If not found default implementation is used.

Example: Deleting all via a given property path referenced entities -> `deleteAll.<propertyPath>`

=== Dependencies

[source, xml, indent=0, tabsize=2]
----
include::{src-incl}pom.xml[tags=mybatis]
----

=== Context

[source, java, indent=0, tabsize=2]
----
include::{main-incl}mybatis/WithMyBatisConfiguration.java[tags=mybatis1]
----

=== Context

[source, java, indent=0, tabsize=2]
----
include::{main-incl}mybatis/WithMyBatisConfiguration.java[tags=mybatis2]
----

=== Context

[source, java, indent=0, tabsize=2]
----
include::{main-incl}mybatis/WithMyBatisConfiguration.java[tags=mybatis3]
----

=== Mapping

[source, xml, indent=0, tabsize=2]
----
include::{src-incl}src/main/resources/de/schauderhaft/spring/data/jdbc/talk/WorkoutMapper.xml[]
----

=== Thanks!

**Kazuki Shimizu**

kazuki43zoo

== `@Query`

image::select.png[canvas,size=contain]

=== `@Query`

[source, java, indent=0, tabsize=2]
----
include::{main-incl}WorkoutRepository.java[tags=query]
----

=== `@Modifying`

[source, java, indent=0, tabsize=2]
----
include::{main-incl}WorkoutRepository.java[tags=modifying]
----

=== RowMapper

[source, java, indent=0, tabsize=2]
----
include::{main-incl}WorkoutRepository.java[tags=rowmapper1]
----

=== RowMapper

[source, java, indent=0, tabsize=2]
----
include::{main-incl}WorkoutRepository.java[tags=rowmapper2]
----

== Integration with SD-Rest

Make it a bootiful Webapplication

=== Spring Data JDBC specific

Almost nothing.

Entities need to be Beans for JSON serializer.

== (Maybe) upcoming

image::future.png[canvas,size=contain]

Not promising anything.

=== Auditing

=== Better CRUD

upserts?

=== Derived Queries

=== Sorting and Paging

=== Named Queries with MyBatis

=== Named Queryies via Properties

=== Spring Boot Support

PoC: https://github.com/schauder/spring-data-jdbc-boot-starter

== TOQAEFT

The One Question Asked Every Freaking Time

=== Is there reactive support?

=== Not yet

=== JDBC is blocking

Might wrap it in a `ThreadPool`

=== Oracle Works on an Async SQL-API

Not Flow/Reactive Stream based

https://events.rainfocus.com/catalog/oracle/oow17/catalogjavaone17?search=CON1491&showEnrolled=false[Java One Slides]

Mailing List: http://mail.openjdk.java.net/mailman/listinfo/jdbc-spec-discuss

http://hg.openjdk.java.net/jdk/sandbox/file/b49fd5dbaab6/src/java.sql/share/classes/java/sql2[repository]

[NOTE.speaker]
====
It really feels like Oracle is on its very own agenda here.

Everybody interested in reactive and Lukas Eder looked at it.
Most feedback didn't had much of an effect.

No visible feedback from other database vendors.
====

=== R2DBC

**R**eactive **R**elational **D**atabase **C**onnectivity

There is a project exploring possibilities: https://github.com/nebhale/r2dbc

== References

* Github: https://github.com/spring-projects/spring-data-jdbc

* Project: https://projects.spring.io/spring-data-jdbc/

* Examples: https://github.com/spring-projects/spring-data-examples/tree/master/jdbc

* Slides on Github: https://github.com/schauder/talk-spring-data-jdbc

* Freeletics: https://www.freeletics.com

include::self.ad[leveloffset=1]
